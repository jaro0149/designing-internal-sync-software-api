In the Model-Driven API, the developer initiates the process by creating a model of the operations using
a specialized language designed for this purpose.
Subsequently, there are two possible approaches to utilizing the model,
depending on the modeling language and technology stack:

\begin{enumerate}
    \item Through generation phase:
    The API generator is employed to generate the code of the API, producing entities that represent
    the input and output structures of the modeled operations.
    To consume and implement the Model-Driven API, developers must execute the generation phase.
    \item Directly by target technology:
    The API generator is bypassed, and the model is directly parsed by the compiler or interpreter
    of the target technology.
    In this scenario, the model is usually more tightly coupled with the source code of the API implementation
    compared to the first approach.
\end{enumerate}

The API can be implemented either manually by the developer or, in simpler cases, generated directly from the model.
For example, the implementation of fundamental Create/Read/Update/Delete (CRUD) operations for a database
or user-facing operations are often directly generated from the model.

Benefits of the Model-Driven API:

\begin{itemize}
    \item Consistency of the API:
    The API is inherently consistent because it is generated from the model, ensuring uniform syntax
    and design patterns.
    The design patterns and approaches described in the guide are automatically applied,
    promoting a consistent API structure.
    API clients can also use the same model to generate or verify API calls.
    \item Documentation:
    The model serves as a foundation for generating API documentation, allowing for an automated documentation process.
    \item Technology-agnostic:
    The model is typically technology-agnostic, enabling the generation of APIs
    in various programming languages and technologies.
    \item Reduction of boilerplate code:
    The model can be leveraged to generate API implementation, including input/output entities,
    reducing the amount of boilerplate code that developers need to write.
    Some generators may also support full or partial generation of queries and mutations.
    \item Less error-prone than manual implementation:
    The model is usually validated by the generator before code generation.
    Moreover, the API itself is constrained by the model, lowering the likelihood of errors.
\end{itemize}

Drawbacks of the Model-Driven API:

\begin{itemize}
    \item Limited flexibility:
    The model is often more constrained than the API implementation, limiting the expression
    of all features of the API in the model.
    \item Additional complexity:
    Introducing a modeling layer adds complexity.
    Developers must learn the modeling language and use the API generator when the model changes.
    Due to this added complexity, the Model-Driven API is typically not used for internal APIs between components
    within the same service.
    It is more suitable for external APIs connecting different services and clients.
    \item Dependency on the model and tools:
    The development process becomes heavily reliant on modeling and generation tools.
    If these tools are not maintained or become obsolete, it could pose significant challenges.
\end{itemize}

Common use-cases of the Model-Driven API:

\begin{itemize}
    \item Multicomponent services:
    When a service comprises multiple components using different technologies or programming languages,
    the Model-Driven API can be employed to generate APIs for each component in the target technology.
    \item Repetitive code generation:
    Model-Driven API is beneficial for generating repetitive code, such as CRUD operations,
    reducing boilerplate code and ensuring consistency.
    For instance, if dealing with a complex data tree and needing to implement CRUD operations for each node,
    Model-Driven API simplifies the process.
\end{itemize}
